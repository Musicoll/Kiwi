<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Kiwi: kiwi::tool::Scheduler&lt; Clock &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kiwi
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacekiwi.html">kiwi</a></li><li class="navelem"><b>tool</b></li><li class="navelem"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">Scheduler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkiwi_1_1tool_1_1_scheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">kiwi::tool::Scheduler&lt; Clock &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class designed to delay tasks' execution between threads that where previously declared.  
 <a href="classkiwi_1_1tool_1_1_scheduler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_kiwi_tool___scheduler_8h_source.html">KiwiTool_Scheduler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_call_back.html">CallBack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scheduler's callback is a task that uses an std::function for conveniency.  <a href="classkiwi_1_1tool_1_1_scheduler_1_1_call_back.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event that associates a task and a execution time.  <a href="classkiwi_1_1tool_1_1_scheduler_1_1_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_queue.html">Queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that holds a list of scheduled events.  <a href="classkiwi_1_1tool_1_1_scheduler_1_1_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract class that the scheduler executes. Caller must override execute function to specify the callback behavior.  <a href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class designed to repetedly call a method at a specified intervall of time. Overriding timerCallBack and calling startTimer will start repetdly calling method.  <a href="classkiwi_1_1tool_1_1_scheduler_1_1_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6f53350d49a4d5b800620a3c2e8cef39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f53350d49a4d5b800620a3c2e8cef39"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>clock_t</b> = Clock</td></tr>
<tr class="separator:a6f53350d49a4d5b800620a3c2e8cef39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3a0748986e8304c470e28f72e9b08c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f3a0748986e8304c470e28f72e9b08c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>time_point_t</b> = typename Clock::time_point</td></tr>
<tr class="separator:a5f3a0748986e8304c470e28f72e9b08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0dac240cadd4a02aaa25c60920bd65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc0dac240cadd4a02aaa25c60920bd65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>duration_t</b> = typename Clock::duration</td></tr>
<tr class="separator:abc0dac240cadd4a02aaa25c60920bd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a506ca9f05908714f94c7b7d18a8c0582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#a506ca9f05908714f94c7b7d18a8c0582">Scheduler</a> ()</td></tr>
<tr class="memdesc:a506ca9f05908714f94c7b7d18a8c0582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a506ca9f05908714f94c7b7d18a8c0582">More...</a><br /></td></tr>
<tr class="separator:a506ca9f05908714f94c7b7d18a8c0582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebee5d0c3bea7cddb9069a247d591a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeebee5d0c3bea7cddb9069a247d591a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#aeebee5d0c3bea7cddb9069a247d591a9">~Scheduler</a> ()</td></tr>
<tr class="memdesc:aeebee5d0c3bea7cddb9069a247d591a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desctructor. <br /></td></tr>
<tr class="separator:aeebee5d0c3bea7cddb9069a247d591a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4569f0b86634d6e74be1b5ccabfe6ad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#a4569f0b86634d6e74be1b5ccabfe6ad0">setThreadAsConsumer</a> ()</td></tr>
<tr class="memdesc:a4569f0b86634d6e74be1b5ccabfe6ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current thread as the consumer thread.  <a href="#a4569f0b86634d6e74be1b5ccabfe6ad0">More...</a><br /></td></tr>
<tr class="separator:a4569f0b86634d6e74be1b5ccabfe6ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeca6317c275e887c5eb0990e4675b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#a1aeca6317c275e887c5eb0990e4675b0">isThisConsumerThread</a> () const </td></tr>
<tr class="memdesc:a1aeca6317c275e887c5eb0990e4675b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check wehter or not this thread is the consumer.  <a href="#a1aeca6317c275e887c5eb0990e4675b0">More...</a><br /></td></tr>
<tr class="separator:a1aeca6317c275e887c5eb0990e4675b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ad5246e57fa0f720f0656f26caf780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#a18ad5246e57fa0f720f0656f26caf780">schedule</a> (std::shared_ptr&lt; <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a> &gt; const &amp;task, duration_t delay=std::chrono::milliseconds(0))</td></tr>
<tr class="memdesc:a18ad5246e57fa0f720f0656f26caf780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delays execution of a task. Shared ownership.  <a href="#a18ad5246e57fa0f720f0656f26caf780">More...</a><br /></td></tr>
<tr class="separator:a18ad5246e57fa0f720f0656f26caf780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21099b6e9f1db495861d24933b67faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#ae21099b6e9f1db495861d24933b67faf">schedule</a> (std::shared_ptr&lt; <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a> &gt; &amp;&amp;task, duration_t delay=std::chrono::milliseconds(0))</td></tr>
<tr class="memdesc:ae21099b6e9f1db495861d24933b67faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delays execution of a task. Transfer ownership.  <a href="#ae21099b6e9f1db495861d24933b67faf">More...</a><br /></td></tr>
<tr class="separator:ae21099b6e9f1db495861d24933b67faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d25db0891833348cd7ca86e50bdad4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#a6d25db0891833348cd7ca86e50bdad4a">schedule</a> (std::function&lt; void(void)&gt; &amp;&amp;func, duration_t delay=std::chrono::milliseconds(0))</td></tr>
<tr class="memdesc:a6d25db0891833348cd7ca86e50bdad4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delays execution of a function by the scheduler.  <a href="#a6d25db0891833348cd7ca86e50bdad4a">More...</a><br /></td></tr>
<tr class="separator:a6d25db0891833348cd7ca86e50bdad4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6410aae282373baf0ff5bccc710429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#a1e6410aae282373baf0ff5bccc710429">defer</a> (std::shared_ptr&lt; <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a> &gt; const &amp;task)</td></tr>
<tr class="memdesc:a1e6410aae282373baf0ff5bccc710429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally schedule a task in the consumer thread.  <a href="#a1e6410aae282373baf0ff5bccc710429">More...</a><br /></td></tr>
<tr class="separator:a1e6410aae282373baf0ff5bccc710429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dd68a31161497c1490369900b93b8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#af0dd68a31161497c1490369900b93b8e">defer</a> (std::shared_ptr&lt; <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a> &gt; &amp;&amp;task)</td></tr>
<tr class="memdesc:af0dd68a31161497c1490369900b93b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally schedule a task in the consumer thread.  <a href="#af0dd68a31161497c1490369900b93b8e">More...</a><br /></td></tr>
<tr class="separator:af0dd68a31161497c1490369900b93b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af575d0226225b8d2065e3941cd9ed7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#a7af575d0226225b8d2065e3941cd9ed7">defer</a> (std::function&lt; void(void)&gt; &amp;&amp;func)</td></tr>
<tr class="memdesc:a7af575d0226225b8d2065e3941cd9ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally schedule a function in the consumer thread.  <a href="#a7af575d0226225b8d2065e3941cd9ed7">More...</a><br /></td></tr>
<tr class="separator:a7af575d0226225b8d2065e3941cd9ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1a5b45118b8db5bde4581f18d993e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#aae1a5b45118b8db5bde4581f18d993e9">unschedule</a> (std::shared_ptr&lt; <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a> &gt; const &amp;task)</td></tr>
<tr class="memdesc:aae1a5b45118b8db5bde4581f18d993e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to cancel the execution of a previously scheduled task.  <a href="#aae1a5b45118b8db5bde4581f18d993e9">More...</a><br /></td></tr>
<tr class="separator:aae1a5b45118b8db5bde4581f18d993e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e9c343155039ac969f13d69b4bf4e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4e9c343155039ac969f13d69b4bf4e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#af4e9c343155039ac969f13d69b4bf4e4">process</a> ()</td></tr>
<tr class="memdesc:af4e9c343155039ac969f13d69b4bf4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes events of the consumer that have reached exeuction time. <br /></td></tr>
<tr class="separator:af4e9c343155039ac969f13d69b4bf4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc0d7769c955aea74e92123e37a2e51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cc0d7769c955aea74e92123e37a2e51"></a>
std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html#a3cc0d7769c955aea74e92123e37a2e51">lock</a> () const </td></tr>
<tr class="memdesc:a3cc0d7769c955aea74e92123e37a2e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the process until the returned lock is out of scope. <br /></td></tr>
<tr class="separator:a3cc0d7769c955aea74e92123e37a2e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Clock = std::chrono::high_resolution_clock&gt;<br />
class kiwi::tool::Scheduler&lt; Clock &gt;</h3>

<p>A class designed to delay tasks' execution between threads that where previously declared. </p>
<p>The scheduler is designed as a singleton that uses multiple event lists. Before processing the scheduler one should create an instance and register all threads that will use the scheduler. One can override the clock used by the scheduler to get time. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a506ca9f05908714f94c7b7d18a8c0582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">kiwi::tool::Scheduler</a>&lt; Clock &gt;::<a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">Scheduler</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Sets current thread as the consumer thread. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1e6410aae282373baf0ff5bccc710429"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">kiwi::tool::Scheduler</a>&lt; Clock &gt;::defer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditionally schedule a task in the consumer thread. </p>
<p>The task is scheduled only if the calling thread is not the consumer thread. Otherwise it is executed right away. </p>

</div>
</div>
<a class="anchor" id="af0dd68a31161497c1490369900b93b8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">kiwi::tool::Scheduler</a>&lt; Clock &gt;::defer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditionally schedule a task in the consumer thread. </p>
<p>The task is scheduled only if the calling thread is not the consumer thread. Otherwise it is executed right away. <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html" title="The abstract class that the scheduler executes. Caller must override execute function to specify the ...">Task</a> is destroyed when executed. </p>

</div>
</div>
<a class="anchor" id="a7af575d0226225b8d2065e3941cd9ed7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">kiwi::tool::Scheduler</a>&lt; Clock &gt;::defer </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditionally schedule a function in the consumer thread. </p>
<p>The function is scheduled only if the calling thread is not the consumer thread. Otherwise it is executed right away. </p>

</div>
</div>
<a class="anchor" id="a1aeca6317c275e887c5eb0990e4675b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">kiwi::tool::Scheduler</a>&lt; Clock &gt;::isThisConsumerThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check wehter or not this thread is the consumer. </p>
<p>This method can be usefull to help decide if a direct call can be made or if the scheduler shall be used. </p>

</div>
</div>
<a class="anchor" id="a18ad5246e57fa0f720f0656f26caf780"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">kiwi::tool::Scheduler</a>&lt; Clock &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>delay</em> = <code>std::chrono::milliseconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delays execution of a task. Shared ownership. </p>
<p>Calling twice this method with same task will cancel the previous scheduled execution and add a new one at specified time. </p>

</div>
</div>
<a class="anchor" id="ae21099b6e9f1db495861d24933b67faf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">kiwi::tool::Scheduler</a>&lt; Clock &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>delay</em> = <code>std::chrono::milliseconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delays execution of a task. Transfer ownership. </p>
<p>Calling twice this method with same task will cancel the previous scheduled execution and add a new one at specified time. </p>

</div>
</div>
<a class="anchor" id="a6d25db0891833348cd7ca86e50bdad4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">kiwi::tool::Scheduler</a>&lt; Clock &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void)&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>delay</em> = <code>std::chrono::milliseconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delays execution of a function by the scheduler. </p>
<p>Internally create a callback that will be executed and destroyed by the scheduler. </p>

</div>
</div>
<a class="anchor" id="a4569f0b86634d6e74be1b5ccabfe6ad0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">kiwi::tool::Scheduler</a>&lt; Clock &gt;::setThreadAsConsumer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current thread as the consumer thread. </p>
<p>This method can be called for instance if the scheduler's constructor is called on another thread than desired consumer. </p>

</div>
</div>
<a class="anchor" id="aae1a5b45118b8db5bde4581f18d993e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classkiwi_1_1tool_1_1_scheduler.html">kiwi::tool::Scheduler</a>&lt; Clock &gt;::unschedule </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classkiwi_1_1tool_1_1_scheduler_1_1_task.html">Task</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to cancel the execution of a previously scheduled task. </p>
<p>If the task is currently being processed by the scheduler, this method does't wait for the execution to finish but only guarantee that further execution will no occur. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Modules/KiwiTool/<a class="el" href="_kiwi_tool___scheduler_8h_source.html">KiwiTool_Scheduler.h</a></li>
<li>Modules/KiwiTool/<a class="el" href="_kiwi_tool___scheduler_8hpp_source.html">KiwiTool_Scheduler.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
