/*
 ==============================================================================
 
 This file is part of the KIWI library.
 - Copyright (c) 2014-2016, Pierre Guillot & Eliott Paris.
 - Copyright (c) 2016-2017, CICM, ANR MUSICOLL, Eliott Paris, Pierre Guillot, Jean Millot.
 
 Permission is granted to use this software under the terms of the GPL v3
 (or any later version). Details can be found at: www.gnu.org/licenses
 
 KIWI is distributed in the hope that it will be useful, but WITHOUT ANY
 WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 
 ------------------------------------------------------------------------------
 
 Contact : cicm.mshparisnord@gmail.com
 
 ==============================================================================
 */

#pragma once

#include <memory>
#include <chrono>
#include <functional>
#include <future>
#include <iostream>

#include <boost/asio.hpp>
#include <boost/asio/steady_timer.hpp>

#include <beast/http.hpp>
#include <beast/core.hpp>

namespace kiwi { namespace network {
    
    using tcp = boost::asio::ip::tcp;
    
    // ================================================================================ //
    //                                        HTTP                                      //
    // ================================================================================ //
    
    class Http
    {
    public: // methods
        
        //! @brief Sends an http request.
        //! @details Returns the response generated by the server. The function blocks until response
        //! is received or error occurs.
        template<class ReqType, class ResType>
        static beast::http::response<ResType>
        write(std::unique_ptr<beast::http::request<ReqType>> request,
              std::string port,
              beast::error_code& error,
              std::chrono::milliseconds timeout = std::chrono::milliseconds(0));
        
        //! @brief Sends an http request asynchronously.
        //! @details Returns the response generated by the server. The function is non blocking. callback
        //! is called on another thread once response is received or error occurs.
        template <class ReqType, class ResType>
        static std::future<void>
        writeAsync(std::unique_ptr<beast::http::request<ReqType>> request,
                   std::string port,
                   std::function<void(beast::http::response<ResType>, beast::error_code)> callback,
                   std::chrono::milliseconds timeout = std::chrono::milliseconds(0));
        
    private: // nested classes
        
        template<class ReqType, class ResType> class Query;
        
    private: // deleted methods
        
        Http() = delete;
        Http(Http const& other) = delete;
        Http(Http && other) = delete;
        Http& operator=(Http const& other) = delete;
        Http& operator=(Http && other) = delete;
    };
    
    // ================================================================================ //
    //                                     HTTP QUERY                                   //
    // ================================================================================ //
    
    template<class ReqType, class ResType>
    class Http::Query
    {
    public: // methods
        
        //! @brief Constructor.
        Query(std::unique_ptr<beast::http::request<ReqType>> request,
              std::string port,
              std::chrono::milliseconds timeout = std::chrono::milliseconds(0));
        
        //! @brief Destructor.
        ~Query();
        
        //! @brief Write the request and get the response.
        beast::http::response<ResType> writeRequest(beast::error_code& error);
        
    private: // methods
        
        //! @internal
        void handleTimeout(boost::system::error_code const& error);
        
        //! @internal
        void handleRead(beast::error_code const& error);
        
        //! @internal
        void handleWrite(beast::error_code const& error);
        
        //! @internal
        void handleConnect(beast::error_code const& error);
        
        //! @internal
        void handleResolve(beast::error_code const& error,
                           tcp::resolver::iterator iterator);
        
    private: // members
        
        std::unique_ptr<beast::http::request<ReqType>>  m_request;
        beast::http::response<ResType>                  m_response;
        std::string                                     m_port;
        boost::asio::io_service                         m_io_service;
        tcp::socket                                     m_socket;
        beast::error_code                               m_error;
        std::chrono::milliseconds                       m_timeout;
        boost::asio::steady_timer                       m_timer;
        beast::flat_buffer                              m_buffer;
        
    private: // deleted methods
        
        Query() = delete;
        Query(Query const& other) = delete;
        Query(Query && other) = delete;
        Query& operator=(Query const& other) = delete;
        Query& operator=(Query && other) = delete;
    };
    
}} // namespace kiwi::network

#include "KiwiNetwork_Http.hpp"
